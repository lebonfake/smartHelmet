package com.example.smarthelmet.data.repository


import android.util.Log
import com.example.smarthelmet.model.Worker
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import kotlinx.coroutines.tasks.await
import java.lang.Exception

class WorkerRepository {

    private val firestore = FirebaseFirestore.getInstance()
    private val workerCollection = firestore.collection("workers") // Firestore collection name

    /**
     * Adds a new worker to Firestore.  The id is generated by Firestore.
     *
     * @param worker The Worker object to add.
     * @return The ID of the newly created worker document in Firestore, or null on failure.
     * @throws Exception if the operation fails.
     */
    suspend fun addWorker(worker: Worker): String {
        return try {
            val documentReference = workerCollection.add(worker).await() // Use .await() for coroutine support
            Log.d("worker", "addWorker: $documentReference ")
            documentReference.id // Return the Firestore-generated ID
        } catch (e: Exception) {
            Log.e("worker", "addWorker: $e ", )
            throw Exception("Failed to add worker: ${e.message}") // Wrap for more context
        }
    }

    /**
     * Retrieves a worker from Firestore by their ID.
     *
     * @param workerId The ID of the worker to retrieve.
     * @return A Worker object if found, null otherwise.
     * @throws Exception if the operation fails.
     */
    suspend fun getWorker(workerId: String): Worker? {
        return try {
            val documentSnapshot = workerCollection.document(workerId).get().await() // Use .await()
            if (documentSnapshot.exists()) {
                documentSnapshot.toObject(Worker::class.java) // Use toObject() for cleaner mapping
            } else {
                null
            }
        } catch (e: Exception) {
            throw Exception("Failed to get worker: ${e.message}")
        }
    }

    /**
     * Updates an existing worker's data in Firestore.
     *
     * @param workerId The ID of the worker to update.
     * @param worker The updated Worker object.
     * @throws Exception if the operation fails.
     */
    suspend fun updateWorker(workerId: String, worker: Worker) {
        try {
            // Use set() with SetOptions.MERGE to update only the provided fields.  Crucial!
            workerCollection.document(workerId).set(worker, SetOptions.merge()).await()
        } catch (e: Exception) {
            throw Exception("Failed to update worker: ${e.message}")
        }
    }

    /**
     * Deletes a worker from Firestore by their ID.
     *
     * @param workerId The ID of the worker to delete.
     * @throws Exception if the operation fails.
     */
    suspend fun deleteWorker(workerId: String) {
        try {
            workerCollection.document(workerId).delete().await()
        } catch (e: Exception) {
            throw Exception("Failed to delete worker: ${e.message}")
        }
    }

    /**
     * Retrieves all workers from Firestore.
     *
     * @return A list of Worker objects.  Returns an empty list if there are no workers.
     * @throws Exception if the operation fails.
     */
    suspend fun getAllWorkers(): List<Worker> {
        return try {
            val querySnapshot = workerCollection.get().await()
            val workers = mutableListOf<Worker>()
            for (document in querySnapshot.documents) {
                val worker = document.toObject(Worker::class.java)
                worker?.let { workers.add(it) } // handle null case.
            }
            Log.d("worker", "getAllWorkers: $workers ")
            workers
        } catch (e: Exception) {
            Log.e("worker", "getAllWorkers: $e", )
            throw Exception("Failed to get all workers: ${e.message}")
        }
    }

    /**
     * Demonstrates a query.  This gets workers with a specific health state.
     * @param healthState The health state to filter by
     * @return A list of workers with the given health state.
     */
    suspend fun getWorkersByHealthState(healthState: String): List<Worker> {
        return try {
            val querySnapshot = workerCollection.whereEqualTo("health_state", healthState).get().await()
            val workers = mutableListOf<Worker>()
            for (document in querySnapshot.documents) {
                val worker = document.toObject(Worker::class.java)
                worker?.let { workers.add(it) }
            }
            return workers
        } catch (e: Exception) {
            throw Exception("Failed to get workers by health state: ${e.message}")
        }
    }
}

